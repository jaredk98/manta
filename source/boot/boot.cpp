#define _CRT_SECURE_NO_WARNINGS

// boot.cpp is the only compiled translation unit for the bootstrap executable
#define HEADER_ONLY_DEBUG ( 1 )
#include <debug.hpp>

#include <boot/toolchains.hpp>
#include <boot/fileio.hpp>
#include <boot/arguments.hpp>

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

static char commandNinja[1024];
static char commandRun[1024];

static char pathOutput[PATH_SIZE];
static char pathOutputBoot[PATH_SIZE];
static char pathOutputBootCache[PATH_SIZE];

static char pathOutputBuild[PATH_SIZE];
static char pathOutputBuildNinja[PATH_SIZE];
static char pathOutputBuildExe[PATH_SIZE];
static char pathOutputBuildCache[PATH_SIZE];

static char pathOutputGenerated[PATH_SIZE];
static char pathOutputGeneratedConfig[PATH_SIZE];

static char pathOutputRuntime[PATH_SIZE];
static char pathOutputPackage[PATH_SIZE];

static char pathSourceManta[PATH_SIZE];
static char pathSourceMantaBuild[PATH_SIZE];
static char pathSourceMantaVendor[PATH_SIZE];

static char pathProjectBuild[PATH_SIZE];

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

int main( int argc, char **argv )
{

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// Parse Arguments & Toolchain

	Arguments args;
	args.parse( argc, argv );
	Toolchain tc { args.toolchain };

	// Print Args
	PrintColor( LOG_YELLOW, "\n>" );
	for( int i = 0; i < argc; i++ ) { PrintColor( LOG_YELLOW, " %s", argv[i] ); }
	Print( "\n" );

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// Setup Paths

	// output/
	strjoin_filepath( pathOutput, "projects", args.project, "output" );

	// output/boot
	strjoin_filepath( pathOutputBoot, pathOutput, "boot" ); // projects/<project>/output/boot
	strjoin_filepath( pathOutputBootCache, pathOutputBoot, "boot.cache" ); // projects/<project>/output/boot/boot.cache

	// output/build
	strjoin_filepath( pathOutputBuild, pathOutput, "build" ); // projects/<project>/output/build
	strjoin_filepath( pathOutputBuildNinja, pathOutputBuild, "build.ninja" ); // projects/<project>/output/build/build.ninja
	strjoin_filepath( pathOutputBuildExe, pathOutputBuild, "build" ); // projects/<project>/output/build/build.exe
	strappend( pathOutputBuildExe, tc.linkerExtensionExe );
	strjoin_filepath( pathOutputBuildCache, pathOutputBuild, "build.cache" ); // projects/<project>/output/build/build.cache

	// output/generated
	strjoin_filepath( pathOutputGenerated, pathOutput, "generated" ); // projects/<project>/output/generated
	strjoin_filepath( pathOutputGeneratedConfig, pathOutputGenerated, "pipeline.generated.hpp" ); // projects/<project>/output/generated/pipeline.generated.hpp

	// output/runtime
	strjoin_filepath( pathOutputRuntime, pathOutput, "runtime" ); // projects/<project>/output/runtime

	// output/package
	strjoin_filepath( pathOutputPackage, pathOutput, "package" ); // projects/<project>/output/package

	// C++ Source Paths
	strjoin_filepath( pathSourceManta, "source" ); // source/manta
	strjoin_filepath( pathSourceMantaBuild, "source", "build" ); // source/build
	strjoin_filepath( pathSourceMantaVendor, "source", "vendor" ); // source/vendor

	// Project Paths
	strjoin_filepath( pathProjectBuild, "projects", args.project, "build" ); // projects/<project>/build


////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// Load & Check Cache

	const bool cacheDirty = PipelineCache::load( args, pathOutputBootCache );

	PrintColor( LOG_WHITE, "Boot Cache... " );
	PrintLnColor( cacheDirty ? LOG_RED : LOG_GREEN, cacheDirty ? "dirty" : "clean" );


////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// Output Directories

	if( cacheDirty )
	{
		// If cache is dirty, clear /output directory
		directory_delete( pathOutputBuild, true );
		directory_delete( pathOutputGenerated, true );
		directory_delete( pathOutputRuntime, true );
		directory_delete( pathOutputPackage, true );
	}

	directory_create( pathOutputBuild );
	directory_create( pathOutputGenerated );
	directory_create( pathOutputRuntime );


////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// Write Core Defines (output/generated/pipeline.generated.hpp)

	if( cacheDirty )
	{
		// Oper Header File
		FILE *file = fopen( pathOutputGeneratedConfig, "wb" );
		ErrorIf( file == nullptr, "Failed to open file '%s' for writing", pathOutputGeneratedConfig );
		char buffer[512];

		// Header Guard
		swrite( "/*\n * File generated by boot.exe--do not edit!\n * Refer to: source/boot/boot.cpp\n */\n", file );
		swrite( "#pragma once\n\n", file );

		// Operating System
		#define MACRO_OPERATING_SYSTEM( macro, value ) \
			strjoin( buffer, "#define " macro " ( ", strcmp( args.os, value ) == 0 ? "1" : "0", " )\n" ); swrite( buffer, file );

		swrite( "// Operating System\n", file );
		MACRO_OPERATING_SYSTEM( "OS_WINDOWS", "windows" );
		MACRO_OPERATING_SYSTEM( "OS_LINUX", "linux" );
		MACRO_OPERATING_SYSTEM( "OS_ANDROID", "android" );
		MACRO_OPERATING_SYSTEM( "OS_MACOS", "macOS" );
		MACRO_OPERATING_SYSTEM( "OS_IOS", "iOS" );
		MACRO_OPERATING_SYSTEM( "OS_IPADOS", "ipadOS" );

		// Toolchain
		#define MACRO_TOOLCHAIN( macro, value ) \
			strjoin( buffer, "#define " macro " ( ", strcmp( args.toolchain, value ) == 0 ? "1" : "0", " )\n" ); swrite( buffer, file );

		swrite( "\n// Toolchain\n", file );
		MACRO_TOOLCHAIN( "TOOLCHAIN_MSVC", "msvc" );
		MACRO_TOOLCHAIN( "TOOLCHAIN_LLVM", "llvm" );
		MACRO_TOOLCHAIN( "TOOLCHAIN_GNU", "gnu" );

		// Graphics API
		#define MACRO_GRAPHICS_API( macro, value ) \
			strjoin( buffer, "#define " macro " ( ", strcmp( args.gfx, value ) == 0 ? "1" : "0", " )\n" ); swrite( buffer, file );

		swrite( "\n// Graphics Backend\n", file );
		MACRO_GRAPHICS_API( "GRAPHICS_D3D12", "d3d12" );
		MACRO_GRAPHICS_API( "GRAPHICS_D3D11", "d3d11" );
		MACRO_GRAPHICS_API( "GRAPHICS_OPENGL", "opengl" );
		MACRO_GRAPHICS_API( "GRAPHICS_VULKAN", "vulkan" );
		MACRO_GRAPHICS_API( "GRAPHICS_METAL", "metal" );

		// Architecture
		#define MACRO_ARCHITECTURE( macro, value ) \
			strjoin( buffer, "#define " macro " ( ", strcmp( args.architecture, value ) == 0 ? "1" : "0", " )\n" ); swrite( buffer, file );

		swrite( "\n// Architecture\n", file );
		MACRO_ARCHITECTURE( "ARCHITECTURE_X64", "x64" );
		MACRO_ARCHITECTURE( "ARCHITECTURE_ARM64", "arm64" );

		// Build Info
		#define MACRO_BUILD_INFO( macro, value ) \
			strjoin( buffer, "#define " macro " \"", value, "\"\n" ); swrite( buffer, file );

		swrite( "\n// Build Info\n", file );
		MACRO_BUILD_INFO( "BUILD_PROJECT", args.project );
		MACRO_BUILD_INFO( "BUILD_OS", args.os );
		MACRO_BUILD_INFO( "BUILD_ARCHITECTURE", args.architecture );
		MACRO_BUILD_INFO( "BUILD_TOOLCHAIN", args.toolchain );
		MACRO_BUILD_INFO( "BUILD_CONFIG", args.config );
		MACRO_BUILD_INFO( "BUILD_GRAPHICS", args.gfx );

		// Close Header File
		swrite( "\n", file );
		ErrorIf( fclose( file ) != 0, "Failed to close file '%s'", pathOutputGeneratedConfig );
	}


////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// Gather Source Files

	// projects/<project>/build/*.cpp
	FileList sources_ProjectBuild { 16 };
	directory_iterate( sources_ProjectBuild, pathProjectBuild, ".cpp", true );

	// manta/*.cpp
	FileList sources_Manta { 16 };
	directory_iterate( sources_Manta, pathSourceManta, ".cpp", false );

	// manta/build/*.cpp
	FileList sources_MantaBuild { 16 };
	directory_iterate( sources_MantaBuild, pathSourceMantaBuild, ".cpp", true );

	// manta/vendor/*.cpp
	FileList sources_MantaVendor { 16 };
	directory_iterate( sources_MantaVendor, pathSourceMantaVendor, ".cpp", true );


////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// Write Ninja File

	// Open File
	FILE *file = fopen( pathOutputBuildNinja, "wb" );
	ErrorIf( file == nullptr, "Failed to open file '%s' for writing", pathOutputBuildNinja );

	// Write Compile Rule
	{
		const bool toolchainMSVC = ( strcmp( args.toolchain, "msvc" ) == 0 );
		const bool toolchainLLVM = ( strcmp( args.toolchain, "llvm" ) == 0 );
		const bool toolchainGNU = ( strcmp( args.toolchain, "gnu" ) == 0 );

		swrite( "rule compile\n", file );
		swrite( toolchainMSVC ? "  deps = msvc\n" : "  deps = gcc\n  depfile = $out.d\n", file );
		swrite( "  command = ", file );
		swrite( tc.compilerName, file );
		swrite( " $in ", file );
		swrite( tc.compilerOutput, file );
		swrite( "$out ", file );

		// Include Paths
		char compilerFlagsIncludes[1024];
		const char *includePath_Manta = ".." SLASH ".." SLASH ".." SLASH ".." SLASH "source"; // root/projects/<project>/output/build -> root/source
		const char *includePath_Generated = ".." SLASH "generated"; // root/projects/<project>/output/build -> root/projects/<project>/output/generated
		const char *includePath_ProjectBuild = ".." SLASH ".." SLASH "build"; // root/projects/<project>/output/build -> root/projects/<project>/build
		snprintf( compilerFlagsIncludes, sizeof( compilerFlagsIncludes ), tc.compilerFlagsIncludes, includePath_Manta, includePath_Generated, includePath_ProjectBuild );

		// Compiler Flags
		char compilerFlags[1024];
		strjoin( compilerFlags, tc.compilerFlags, " ", tc.compilerFlagsWarnings, " ", compilerFlagsIncludes );
		swrite( compilerFlags, file );
	}

	// Write Link Rule
	{
		swrite( "\n\nrule link\n  command = ", file );
		swrite( tc.linkerName, file );
		swrite( " $in ", file );
		swrite( tc.linkerOutput, file );
		swrite( "$out ", file );

		char linkerFlags[1024];
		strjoin( linkerFlags, tc.linkerFlags );

		#if PIPELINE_OS_WINDOWS
		linkerflags_add_library( linkerFlags, sizeof( linkerFlags ), tc, "winmm" ); // windows timer
		#endif

		swrite( linkerFlags, file );
		swrite( "\n", file );
	}

	// Build Objects
	{
		const char *ninjaBuild = "\nbuild objects" SLASH; // root/projects/<project>/output/build/objects/
		const char *ninjaCompile = ": compile " ".." SLASH ".." SLASH ".." SLASH ".." SLASH; // root/projects/<project>/output/build -> // root/

		// projects/<project>/build/*.cpp's
		for( int i = 0; i < sources_ProjectBuild.count; i++ )
		{
			char objFilePath[512];
			path_change_extension( objFilePath, sizeof( objFilePath ), sources_ProjectBuild.data[i].path, tc.linkerExtensionObj );

			// Write Command
			swrite( ninjaBuild, file );
			swrite( objFilePath, file );
			swrite( ninjaCompile, file );
			swrite( sources_ProjectBuild.data[i].path, file );
		}

		// manta/*.cpp's
		swrite( "\n", file );
		for( int i = 0; i < sources_Manta.count; i++ )
		{
			char objFilePath[512];
			path_change_extension( objFilePath, sizeof( objFilePath ), sources_Manta.data[i].path, tc.linkerExtensionObj );

			// Write Command
			swrite( ninjaBuild, file );
			swrite( objFilePath, file );
			swrite( ninjaCompile, file );
			swrite( sources_Manta.data[i].path, file );
		}

		// manta/build/*.cpp's
		for( int i = 0; i < sources_MantaBuild.count; i++ )
		{
			char objFilePath[512];
			path_change_extension( objFilePath, sizeof( objFilePath ), sources_MantaBuild.data[i].path, tc.linkerExtensionObj );

			// Write Command
			swrite( ninjaBuild, file );
			swrite( objFilePath, file );
			swrite( ninjaCompile, file );
			swrite( sources_MantaBuild.data[i].path, file );
		}

		// manta/vendor/*.cpp's
		for( int i = 0; i < sources_MantaVendor.count; i++ )
		{
			char objFilePath[512];
			path_change_extension( objFilePath, sizeof( objFilePath ), sources_MantaVendor.data[i].path, tc.linkerExtensionObj );

			// Write Command
			swrite( ninjaBuild, file );
			swrite( objFilePath, file );
			swrite( ninjaCompile, file );
			swrite( sources_MantaVendor.data[i].path, file );
		}
	}

	// Build Executable
	{
		// Write Command
		swrite( "\n\nbuild build", file );
		swrite( tc.linkerExtensionExe, file );
		swrite( ": link ", file );

		// Write Input (projects/<project>)
		for( int i = 0; i < sources_ProjectBuild.count; i++ )
		{
			char objFilePath[512];
			path_change_extension( objFilePath, sizeof( objFilePath ), sources_ProjectBuild.data[i].path, tc.linkerExtensionObj );

			swrite( "objects" SLASH, file );
			swrite( objFilePath, file );
			swrite( " ", file );
		}

		// Write Input (manta/)
		for( int i = 0; i < sources_Manta.count; i++ )
		{
			char objFilePath[512];
			path_change_extension( objFilePath, sizeof( objFilePath ), sources_Manta.data[i].path, tc.linkerExtensionObj );

			swrite( "objects" SLASH, file );
			swrite( objFilePath, file );
			swrite( " ", file );
		}

		// Write Input (manta/build)
		for( int i = 0; i < sources_MantaBuild.count; i++ )
		{
			char objFilePath[512];
			path_change_extension( objFilePath, sizeof( objFilePath ), sources_MantaBuild.data[i].path, tc.linkerExtensionObj );

			swrite( "objects" SLASH, file );
			swrite( objFilePath, file );
			swrite( " ", file );
		}

		// Write Input (manta/vendor)
		for( int i = 0; i < sources_MantaVendor.count; i++ )
		{
			char objFilePath[512];
			path_change_extension( objFilePath, sizeof( objFilePath ), sources_MantaVendor.data[i].path, tc.linkerExtensionObj );

			swrite( "objects" SLASH, file );
			swrite( objFilePath, file );
			swrite( " ", file );
		}
	}

	// Close File
	swrite( "\n", file );
	ErrorIf( fclose( file ) != 0, "Failed to close file '%s'", pathOutputBuildNinja );


////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// Start Ninja

	Print( "\n" );
	strjoin( commandNinja, "ninja -C ", pathOutputBuild );
	const int code = system( commandNinja );
	if( code != 0 ) { Error( "ninja failed! Code: %d (%s)", code, commandNinja ); }


////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// Check dirty build.exe

	FileTime bootCacheTime, buildExeTime;
	file_time( pathOutputBootCache, &bootCacheTime );
	file_time( pathOutputBuildExe, &buildExeTime );
	if( file_time_newer( buildExeTime, bootCacheTime ) )
	{
		// If build.exe is new, we need to force clear the build cache
		file_delete( pathOutputBuildCache );
	}


////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// Save Cache

	PipelineCache::save( args, pathOutputBootCache );


////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// Start build.exe

	strappend( commandRun, pathOutputBuildExe );
	for( int i = 1; i < argc; i++ )
	{
		strappend( commandRun, " " );
		strappend( commandRun, argv[i] );
	}
	if( system( commandRun ) != 0 ) { return 1; }


////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// Success

	return 0;
}