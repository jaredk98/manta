/*
 * File generated by build.exe--do not edit!
 * Refer to: source/build/objects.cpp (objects::GenerateSource)
 *
 * Provides implementations for source/manta/objects.hpp internals and output/generated/objects.generated.hpp
 */

// OBJECT SYSTEM INCLUDES
#include <manta/objects.hpp>
#include <manta/memory.hpp>
#include <vendor/new.hpp>

// SOURCE_INCLUDES
#include <scene.hpp>
#include <manta/window.hpp>
#include <manta/input.hpp>
#include <manta/draw.hpp>
#include <manta/math.hpp>
#include <manta/random.hpp>


////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

#define INHERIT

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

byte *iobjects::OBJECT_CTOR_MANUAL_BUFFER = nullptr;
byte *iobjects::OBJECT_CTOR_DEFAULT_BUFFER = nullptr;
u32 iobjects::OBJECT_CTOR_BUFFER_SIZE = 0;
u32 iobjects::OBJECT_CTOR_BUFFER_OFFSET[OBJECT_TYPE_COUNT];

const u16 iobjects::OBJECT_TYPE_BUCKET_CAPACITY[OBJECT_TYPE_COUNT] =
{
	0, 1024, 1024, 1024, 
};

const i32 iobjects::OBJECT_TYPE_MAX_COUNT[OBJECT_TYPE_COUNT] =
{
	0, -1, -1, -1, 
};

const u16 iobjects::OBJECT_TYPE_INHERITANCE_DEPTH[OBJECT_TYPE_COUNT] =
{
	0, 1, 1, 1, 
};

const u16 iobjects::OBJECT_TYPE_SIZE[OBJECT_TYPE_COUNT] =
{
	sizeof( iobjects::BASE_OBJECT_t ), sizeof( iobjects::obj_asteroid_t ), sizeof( iobjects::obj_projectile_t ), sizeof( iobjects::obj_rocket_t ), 
};


#if COMPILE_DEBUG
const char *iobjects::OBJECT_TYPE_NAME[OBJECT_TYPE_COUNT] =
{
	"BASE_OBJECT", "obj_asteroid", "obj_projectile", "obj_rocket", 
};
#endif

#define OBJECT_CONSTRUCTOR_OFFSET( typeID ) \
	iobjects::OBJECT_CTOR_BUFFER_OFFSET[typeID] = iobjects::OBJECT_CTOR_BUFFER_SIZE; \
	iobjects::OBJECT_CTOR_BUFFER_SIZE += iobjects::OBJECT_TYPE_SIZE[typeID];

#define OBJECT_CONSTRUCTOR_DATA( typeID, type ) \
	{ new ( iobjects::OBJECT_CTOR_DEFAULT_BUFFER + iobjects::OBJECT_CTOR_BUFFER_OFFSET[typeID] ) type(); }

bool iobjects::init()
{
	OBJECT_CONSTRUCTOR_OFFSET( BASE_OBJECT );
	OBJECT_CONSTRUCTOR_OFFSET( obj_asteroid );
	OBJECT_CONSTRUCTOR_OFFSET( obj_projectile );
	OBJECT_CONSTRUCTOR_OFFSET( obj_rocket );
	// ...

	iobjects::OBJECT_CTOR_MANUAL_BUFFER = reinterpret_cast<byte *>( memory_alloc( iobjects::OBJECT_CTOR_BUFFER_SIZE ) );
	if( iobjects::OBJECT_CTOR_MANUAL_BUFFER == nullptr ) { return false; }

	iobjects::OBJECT_CTOR_DEFAULT_BUFFER = reinterpret_cast<byte *>( memory_alloc( iobjects::OBJECT_CTOR_BUFFER_SIZE ) );
	if( iobjects::OBJECT_CTOR_DEFAULT_BUFFER == nullptr ) { return false; }

	OBJECT_CONSTRUCTOR_DATA( BASE_OBJECT, iobjects::BASE_OBJECT_t );
	OBJECT_CONSTRUCTOR_DATA( obj_asteroid, iobjects::obj_asteroid_t );
	OBJECT_CONSTRUCTOR_DATA( obj_projectile, iobjects::obj_projectile_t );
	OBJECT_CONSTRUCTOR_DATA( obj_rocket, iobjects::obj_rocket_t );
	// ...

	return true;
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void ObjectContext::event_destroy()
{
}

void ObjectContext::event_initialize()
{
}

void ObjectContext::event_frame_start( const Delta delta )
{
}

void ObjectContext::event_frame_end( const Delta delta )
{
}

void ObjectContext::event_step_custom( const Delta delta )
{
}

void ObjectContext::event_step_gui( const Delta delta )
{
}

void ObjectContext::event_step( const Delta delta )
{
	foreach_object( ( *this ), obj_asteroid, handle ) { handle->event_step( delta ); }
	foreach_object( ( *this ), obj_projectile, handle ) { handle->event_step( delta ); }
	foreach_object( ( *this ), obj_rocket, handle ) { handle->event_step( delta ); }
}

void ObjectContext::event_draw_custom( const Delta delta )
{
}

void ObjectContext::event_draw_gui( const Delta delta )
{
}

void ObjectContext::event_draw( const Delta delta )
{
	foreach_object( ( *this ), obj_asteroid, handle ) { handle->event_draw( delta ); }
	foreach_object( ( *this ), obj_projectile, handle ) { handle->event_draw( delta ); }
	foreach_object( ( *this ), obj_rocket, handle ) { handle->event_draw( delta ); }
}

void ObjectContext::event_sleep( const Delta delta )
{
}

void ObjectContext::event_wake( const Delta delta )
{
}

void ObjectContext::event_flag( const u64 code )
{
}

void ObjectContext::event_partition( void *ptr )
{
}

void ObjectContext::event_ui_mask( void *ptr )
{
}

void ObjectContext::event_save( byte *buffer )
{
}

void ObjectContext::event_load( byte *buffer )
{
}

void ObjectContext::event_network_send( byte *buffer )
{
}

void ObjectContext::event_network_receive( byte *buffer )
{
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

template <> ObjectHandle<BASE_OBJECT> Object::handle<BASE_OBJECT>( const ObjectContext &context ) const
{
	return { context.object_pointer( *this ) };
}

template <> ObjectHandle<obj_asteroid> Object::handle<obj_asteroid>( const ObjectContext &context ) const
{
	return { context.object_pointer( *this ) };
}

template <> ObjectHandle<obj_projectile> Object::handle<obj_projectile>( const ObjectContext &context ) const
{
	return { context.object_pointer( *this ) };
}

template <> ObjectHandle<obj_rocket> Object::handle<obj_rocket>( const ObjectContext &context ) const
{
	return { context.object_pointer( *this ) };
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void iobjects::BASE_OBJECT_t::event_create()
{
	/* do nothing */
}

void iobjects::BASE_OBJECT_t::event_destroy()
{
	/* do nothing */
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

iobjects::obj_asteroid_t::obj_asteroid_t( const float _size )
{
	size = _size;
	speed = random::value<float>( 30.0f, 64.0f );
	direction = random::value<float>( 360.0f );

	const int side = choose( 0, 1, 2, 3 );
	switch( side )
	{
		case 0: // Left
		{
			x = 0 - border * 0.5f;
			y = random::value<float>( 0.0f, static_cast<float>( window::height ) );
		}
		break;

		case 1: // Right
		{
			x = static_cast<float>( window::width ) + border * 0.5f;
			y = random::value<float>( 0.0f, static_cast<float>( window::height ) );
		}
		break;

		case 2: // Top
		{
			x = random::value<float>( 0.0f, static_cast<float>( window::width ) );
			y = 0 - border * 0.5f;
		}
		break;

		case 3: // Bottom
		{
			x = random::value<float>( 0.0f, static_cast<float>( window::width ) );
			y = static_cast<float>( window::height ) + border * 0.5f;
		}
		break;
	}
}

iobjects::obj_asteroid_t::obj_asteroid_t( const float _x, const float _y, const float _direction, const float _speed, const float _size )
{
	x = _x;
	y = _y;
	direction = _direction;
	speed = _speed;
	size = _size;
}

void iobjects::obj_asteroid_t::event_create()
{
	rotation = random::value<float>( 360.0 );

	health = 100.0f * size;
}

void iobjects::obj_asteroid_t::event_step( const Delta delta )
{
	// Movement
	x += lengthdir_x( speed * delta, direction );
	y += lengthdir_y( speed * delta, direction );

	rotation += delta * speed * ( id.index % 2 == 0 ? -1.0f : 1.0f );

	// Destroy
	constexpr float border = 256.0f;
	if( x < -border || x > static_cast<float>( window::width + border ) || y < -border || y > static_cast<float>( window::height + border ) )
	{
		Scene::objects.destroy( id );
		return;
	}

	// Bullets
	const float radiusSqr = ( radius * size ) * ( radius * size );
	for( auto projectile : Scene::objects.objects<obj_projectile>() )
	{
		if( vec2_length_sqr( x, y, projectile->x, projectile->y ) < radiusSqr )
		{
			Scene::objects.destroy( projectile->id );
			health -= 50.0f;
		}
	}

	// Health
	if( health <= 0.0f )
	{
		// Create Children
		if( size >= 2.0f )
		{
			Scene::objects.create<obj_asteroid>( x, y, direction - 45, speed, size * 0.5f );
			Scene::objects.create<obj_asteroid>( x, y, direction + 45, speed, size * 0.5f );
			Scene::objects.create<obj_asteroid>( x, y, direction - 135, speed, size * 0.5f );
			Scene::objects.create<obj_asteroid>( x, y, direction + 135, speed, size * 0.5f );
		}

		// Destroy Self
		Scene::score += 1 + static_cast<int>( size );
		Scene::objects.destroy( id );
		return;
	}
}

void iobjects::obj_asteroid_t::event_draw( const Delta delta )
{
	const float r = radius * size;
	draw_sprite_angle( spr_asteroid, 0, x, y, rotation, size, size, c_white, 0.0f );
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void iobjects::obj_projectile_t::event_create()
{
}

void iobjects::obj_projectile_t::event_step( const Delta delta )
{
	// Movement
	x += lengthdir_x( speed * delta, direction );
	y += lengthdir_y( speed * delta, direction );

	// Destroy
	if( x < 0.0f || x > static_cast<float>( window::width ) || y < 0.0f || y > static_cast<float>( window::height ) )
	{
		Scene::objects.destroy( id );
		return;
	}
}

void iobjects::obj_projectile_t::event_draw( const Delta delta )
{
	draw_sprite_angle( spr_fire_beam, 0, x, y, direction, 1.0f, 1.0f, c_white, 0.0f );
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void iobjects::obj_rocket_t::event_create()
{
	x = window::width * 0.5f;
	y = window::height * 0.5f;
}

void iobjects::obj_rocket_t::event_step( const Delta delta )
{
	// Direction
	if( keyboard::check( vk_a ) ) { direction -= 180.0f * delta; }
	if( keyboard::check( vk_d ) ) { direction += 180.0f * delta; }
	if( keyboard::check( vk_w ) ) { speed += 160.0f * delta; }
	if( keyboard::check( vk_s ) ) { speed -= 120.0f * delta; }
	speed = clamp( speed, -60.0f, 240.0f );

	// Wrap around screen
	x = wrap( x, 0.0f, static_cast<float>( window::width ) );
	y = wrap( y, 0.0f, static_cast<float>( window::height ) );

	// Movement
	x += lengthdir_x( speed * delta, direction );
	y += lengthdir_y( speed * delta, direction );

	// Projectiles
	shootTimer += delta;
	if( keyboard::check( vk_space ) )
	{
		if( shootTimer >= ( keyboard::check( vk_control ) ? 0.01f : 0.1f ) )
		{
			// Create Projectile
			Object projectile = Scene::objects.create( obj_projectile );
			if( auto handle = projectile.handle<obj_projectile>( Scene::objects ); handle )
			{
				const float spawnX = lengthdir_x( 28, direction + ( shootSide ? 90.0f : -90.0f ) ) + lengthdir_x( 20, direction );
				const float spawnY = lengthdir_y( 28, direction + ( shootSide ? 90.0f : -90.0f ) ) + lengthdir_y( 20, direction );

				handle->x = x + spawnX;
				handle->y = y + spawnY;

				handle->direction = direction + random::value<float>( -4.0f, 4.0f );
				handle->speed = speed + 500.0f;

				speed -= 0.5f;
			}

			// Reset timer & alternate shoot side
			shootTimer = 0.0f;
			shootSide = !shootSide;
		}
	}

	// Death
	for( auto asteroid : Scene::objects.objects<obj_asteroid>() )
	{
		const float radiusSqr = ( asteroid->radius * asteroid->size ) * ( asteroid->radius * asteroid->size );
		if( vec2_length_sqr( x, y, asteroid->x, asteroid->y ) < radiusSqr )
		{
			Scene::objects.destroy( id );
			return;
		}
	}
}

void iobjects::obj_rocket_t::event_draw( const Delta delta )
{
	draw_sprite_angle( spr_rocket_ship, 0, x, y, direction, 1.0f, 1.0f, c_white, 0.0f );
}

